-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/michaeljklein/end-list#readme</a>
@package end-list
@version 0.1.0.0

module Control.Foldl.Utils

-- | Feed an input value to a <a>Fold</a>, updating its internal state
feed :: Fold a b -> a -> Fold a b

-- | Feed an input value to a <a>FoldM</a>, updating its internal
--   <a>Monad</a>ic state
feedM :: Monad m => FoldM m a b -> a -> FoldM m a b

-- | Extract the current result from a <a>FoldM</a>
extractM :: Monad m => FoldM m a b -> m b

module Data.List.End

-- | Insert with a given <a>Ordering</a> and <a>Fold</a> to update the end
insertBy :: Fold a e -> (a -> a -> Ordering) -> a -> EndList e' a -> EndList e a

-- | Insert with a given <a>Ordering</a> and <a>FoldM</a> to update the end
insertByM :: Monad m => FoldM m a e -> (a -> a -> Ordering) -> a -> EndList e' a -> m (EndList e a)

-- | Maximum using the given ordering
maximumBy :: (a -> a -> Ordering) -> EndList e a -> a

-- | Minimum using the given ordering
minimumBy :: (a -> a -> Ordering) -> EndList e a -> a

-- | Generic length, using the supplied function to calculate the length of
--   the end.
genericLength :: Num i => (e -> i) -> EndList e a -> i

-- | Strict version of <a>genericLength</a>
strictGenericLength :: Num i => (e -> i) -> EndList e a -> i

-- | Take some number of elements and use the given <a>Fold</a> to
--   calculate the new end
genericTake :: Integral i => Fold a e -> i -> EndList e' a -> EndList e a

-- | <a>genericTake</a>, where a <a>FoldM</a> is provided to update the end
genericTakeM :: (Integral i, Monad m) => FoldM m a e -> i -> EndList e' a -> m (EndList e a)

-- | Drop the given number of elements from the front of an <a>EndList</a>
--   or none if negative.
genericDrop :: Integral i => i -> EndList e a -> EndList e a

-- | Split at the given index, using the given <a>Fold</a> to provide the
--   end of the prefix, or split at <tt>0</tt> if negative.
genericSplitAt :: Integral i => Fold a e' -> i -> EndList e a -> (EndList e' a, EndList e a)

-- | <a>genericSplitAt</a>, where a <a>FoldM</a> is provided to calculate
--   the end of the prefix
genericSplitAtM :: (Integral i, Monad m) => FoldM m a e' -> i -> EndList e a -> m (EndList e' a, EndList e a)

-- | The element of an <a>EndList</a> at the given index. Throws an error
--   if given a negative argument
genericIndex :: Integral i => EndList e a -> i -> a

-- | A list of elements of type <tt>a</tt> where the end of the list
--   contains a single element of type <tt>e</tt>
data EndList e a
End :: e -> EndList e a
(:.) :: a -> (EndList e a) -> EndList e a

-- | Convert a list and an end value to an <a>EndList</a>
fromListWithEnd :: e -> [a] -> EndList e a

-- | Convert a list and an end value calculated through a left scan to an
--   <a>EndList</a>
fromListWithEndF :: (a -> e -> e) -> e -> [a] -> EndList e a

-- | <a>fromListWithEndF</a> with an <a>Applicative</a> state
fromListWithEndA :: Applicative f => (a -> f e -> f e) -> f e -> [a] -> f (EndList e a)

-- | The first element of an <a>EndList</a>, lazily matched
ehead :: EndList e a -> a

-- | The tail of an <a>EndList</a>, lazily matched
etail :: EndList e a -> EndList e a

-- | Concatenate <a>EndList</a>s, combining their ends with
--   <tt>(<a>&lt;&gt;</a>)</tt>
econcat :: Semigroup e => EndList e (EndList e a) -> EndList e a

-- | Concatenate <a>EndList</a>s, combining their ends with the given
--   method
econcatWith :: (e -> e -> e) -> EndList e (EndList e a) -> EndList e a

-- | Convert an <a>EndList</a> to a <a>Free</a> representation
endListToFree :: EndList e a -> Free ((,) a) e

-- | Convert a <a>Free</a> representation to an <a>EndList</a>
freeToEndList :: Free ((,) a) e -> EndList e a

-- | Convert an <a>EndList</a> to a <a>Monad</a>ic <a>FreeT</a>
--   representation
endListToFreeM :: Monad m => EndList e a -> FreeT ((,) a) m e

-- | Convert a <a>Monad</a>ic <a>FreeT</a> representation to an
--   <a>EndList</a>
freeToEndListM :: Monad m => FreeT ((,) a) m e -> m (EndList e a)

-- | Use a <a>Fold</a> to replace the end of an <a>EndList</a>
resetEndWith :: EndList e' a -> Fold a e -> EndList e a

-- | Use a <a>FoldM</a> to replace the end of an <a>EndList</a>
resetEndWithM :: Monad m => EndList e' a -> FoldM m a e -> m (EndList e a)

-- | <a>span</a>, where the prefix that satisfies the predicate is the
--   non-end part of the <a>EndList</a> and the rest of the input is stored
--   in the <a>End</a>.
--   
--   For example:
--   
--   <pre>
--   位&gt; spanEnd (&lt; 4) [1..6]
--   1 :. 2 :. 3 :. End [4,5,6]
--   </pre>
spanEnd :: (a -> Bool) -> [a] -> EndList [a] a

-- | Example application of <a>EndList</a>: a list that's all <tt>b</tt>'s,
--   then all <tt>a</tt>'s, then all <tt>b</tt>'s, ..
newtype PartList a b
PartList :: EndList (Maybe (PartList b a)) b -> PartList a b
[runPartList] :: PartList a b -> EndList (Maybe (PartList b a)) b

-- | Convert a list of <a>Either</a>'s to a <a>Either</a> <a>PartList</a>
--   possibility
partEither :: [Either a b] -> Either (PartList b a) (PartList a b)

-- | <a>Left</a> for even bits and <a>Right</a> for odd:
--   
--   <pre>
--   位&gt; enumEither 1265
--   [Right (),Left (),Left (),Left (),Right (),Right (),Right (),Right (),Left (),Left (),Right ()]--
--   </pre>
enumEither :: Integral t => t -> [Either () ()]

-- | Convert an <a>Integral</a> input to a list of <a>Either</a>s whose
--   values are <tt>[0..]</tt> and are <a>Left</a> or <a>Right</a> as in
--   <a>enumEither</a>
--   
--   <pre>
--   位&gt; enumEithers 1265
--   [Right 0,Left 1,Left 2,Left 3,Right 4,Right 5,Right 6,Right 7,Left 8,Left 9,Right 10]
--   </pre>
--   
--   <pre>
--   位&gt; partEither $ enumEithers 1265
--   Right
--     (PartList
--        { runPartList =
--            0 :.
--            End
--              Just
--              (PartList
--                 { runPartList =
--                     1 :. 2 :. 3 :.
--                     End
--                       Just
--                       (PartList
--                          { runPartList =
--                              4 :. 5 :. 6 :. 7 :.
--                              End
--                                Just
--                                (PartList
--                                   { runPartList =
--                                       8 :. 9 :.
--                                       End
--                                         Just
--                                         (PartList
--                                            {runPartList = 10 :. End Nothing})
--                                   })
--                          })
--                 })
--        })
--   </pre>
enumEithers :: (Enum b, Num b, Integral t) => t -> [Either b b]
instance (GHC.Show.Show b, GHC.Show.Show a) => GHC.Show.Show (Data.List.End.PartList a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Data.List.End.PartList a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.List.End.PartList a b)
instance GHC.Generics.Generic1 (Data.List.End.EndList e)
instance GHC.Generics.Generic (Data.List.End.EndList e a)
instance GHC.Base.Functor (Data.List.End.EndList e)
instance (GHC.Classes.Ord a, GHC.Classes.Ord e) => GHC.Classes.Ord (Data.List.End.EndList e a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq e) => GHC.Classes.Eq (Data.List.End.EndList e a)
instance (GHC.Show.Show e, GHC.Show.Show a) => GHC.Show.Show (Data.List.End.EndList e a)
instance Data.Bifunctor.Bifunctor Data.List.End.EndList
instance Data.Biapplicative.Biapplicative Data.List.End.EndList
instance Data.Bifoldable.Bifoldable Data.List.End.EndList
instance Data.Bitraversable.Bitraversable Data.List.End.EndList
instance Data.Foldable.Foldable (Data.List.End.EndList e)
instance Data.Traversable.Traversable (Data.List.End.EndList e)
instance GHC.Base.Monoid e => GHC.Base.Applicative (Data.List.End.EndList e)
instance GHC.Base.Monoid e => GHC.Base.Alternative (Data.List.End.EndList e)
instance GHC.Base.Monoid e => GHC.Base.Monad (Data.List.End.EndList e)
instance GHC.Base.Monoid e => Control.Monad.Zip.MonadZip (Data.List.End.EndList e)
instance GHC.Base.Monoid e => Control.Monad.Fix.MonadFix (Data.List.End.EndList e)
